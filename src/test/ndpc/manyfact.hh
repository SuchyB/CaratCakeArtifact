// C++ program generated by NDPC_gen_CXX
// 
//
// basic declarations

/*

  Basic base classes needed to interface with generated code

  We assume the following scalar types are available:

  int (and family), float (and family), string

*/


// basic collection type
// derive from this to create a custom interface
// 
// T must minimally support:
//     - operator= 
//
// operator[] must be fully parallel
//
// referencing past numitems should automatically expand
//
template <typename T> class Collection {
public: 
    Collection() {};
    Collection(int numitems) {} ;
    Collection(const Collection<T> &rhs) {} ;
    virtual ~Collection() {} ;

    
    virtual int numitems() const = 0;

    virtual Collection<T> & operator=(const Collection<T> &rhs) = 0;

    static struct OutOfBounds {} outofbounds;

    virtual T const & operator[](const int offset) const = 0;
    virtual T & operator[](const int offset) = 0;
};

int __attribute__ ((noinline)) singlefact(int &ret, int &a);
int __attribute__ ((noinline)) manyfact(Collection<int> &ret, Collection<int> &c);




int __attribute__ ((noinline)) singlefact(int &ret, int &a)
{
 bool __t0;
 int __t1;
 int __t2;
 int __t3;
 int __t4;
 int __t5;
 int __t6;
 int __t7;
 int __t8;
 int __t9;
__t3 = a ;
 __t4 = 1 ;
 __t0 = __t3 <= __t4 ;
 if (__t0) { 
__t1 = a ;
  ret = __t1; 
} else {
__t5 = a ;
__t8 = a ;
 __t9 = -1 ;
 __t7 = __t8 + __t9 ;
 if (singlefact(__t6, __t7)) { /* FAILURE OF CALL HANDLED HERE */ }
 __t2 = __t5 * __t6 ;
  ret=__t2;
}  return 0;
}






int __attribute__ ((noinline)) manyfact(Collection<int> &ret, Collection<int> &c)
{
 int __t10;
 int __t11;
 { 
 int x;
 int __t12;
 int __t13;
 __t13 = c.numitems();
 // parallelize this!
 for (__t12 = 0; __t12 < __t13; __t12++) { 
  x = c[__t12];
if (ndpc_fork_preempt_thread()==ndpc_my_preempt_thread()) {

 __t11 = x ;
 if (singlefact(__t10, __t11)) { /* FAILURE OF CALL HANDLED HERE */ }
ret[__t12] = __t10;
return 0;
}
}
ndpc_join_child_preempt_threads();
}
  return 0;
}



// Done with code generation

